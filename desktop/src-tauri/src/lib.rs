//! OddsManager desktop â€“ Rust backend.
//!
//! Provides commands for managing X (Twitter) list monitors: store configs,
//! parse list URLs, and generate TamperMonkey scripts.

use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;
use std::process::Command;
use tauri::Manager;

/// One saved monitor: list URL and keywords to watch.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Monitor {
    pub id: String,
    pub name: String,
    pub list_url: String,
    pub keywords: Vec<String>,
    /// Optional: refresh interval in minutes (for generated script).
    #[serde(default = "default_refresh_minutes")]
    pub refresh_minutes: u32,
}

fn default_refresh_minutes() -> u32 {
    1
}

/// Path to the JSON file where we store monitors (in app data dir).
fn monitors_path(app: &tauri::AppHandle) -> Result<PathBuf, String> {
    let dir = app
        .path()
        .app_data_dir()
        .map_err(|e| e.to_string())?;
    fs::create_dir_all(&dir).map_err(|e| e.to_string())?;
    Ok(dir.join("monitors.json"))
}

/// Parse X/Twitter list URL to extract list id (numeric or slug).
/// Supports: https://x.com/i/lists/52021139, https://twitter.com/i/lists/52021139,
/// and https://x.com/username/lists/12345 style URLs.
pub fn parse_list_id_from_url(url: &str) -> Option<String> {
    let url = url.trim();
    if url.is_empty() {
        return None;
    }
    // After split('/').filter: ["https:", "x.com", "i", "lists", "52021139"] or ["https:", "x.com", "user", "lists", "123"]
    let segments: Vec<&str> = url.split('/').filter(|s| !s.is_empty()).collect();
    if segments.len() >= 5 {
        // host, "i", "lists", id
        if segments.get(2).copied() == Some("i") && segments.get(3).copied() == Some("lists") {
            return Some(segments[4].to_string());
        }
        // host, username, "lists", id
        if segments.get(3).copied() == Some("lists") {
            return Some(segments[4].to_string());
        }
    }
    if segments.len() == 4 && segments.get(2).copied() == Some("lists") {
        return Some(segments[3].to_string());
    }
    None
}

/// Generate the full TamperMonkey script content for this monitor.
pub fn generate_tampermonkey_script(monitor: &Monitor) -> String {
    let list_id = parse_list_id_from_url(&monitor.list_url).unwrap_or_else(|| "LIST_ID".to_string());
    let keywords_js: String = monitor
        .keywords
        .iter()
        .map(|k| format!("{:?}", k))
        .collect::<Vec<_>>()
        .join(", ");
    let name_escaped = monitor.name.replace("\\", "\\\\").replace("\"", "\\\"");
    let version = chrono::Utc::now().format("%Y.%m.%d");
    format!(
        r#"// ==UserScript==
// @name         X List Monitor: {}
// @namespace    http://tampermonkey.net/
// @version      {}
// @description  X list keywords -> DB (generated by OddsManager). Run python news/tweets_api.py
// @match        https://x.com/*
// @match        https://twitter.com/*
// @grant        GM_xmlhttpRequest
// @run-at       document-end
// ==/UserScript==

(function() {{
    'use strict';

    const API_URL = "http://localhost:8765";
    const KEYWORDS = [{}];
    const LIST_ID = "{}";
    const REFRESH_MINUTES = {};
    const CATCH_UP_THRESHOLD_MINUTES = 5;
    const STORAGE_KEY = "X_MONITOR_SEEN_CACHE_" + LIST_ID;
    const STATE_KEY = "X_MONITOR_STATE_" + LIST_ID;
    const MAX_CACHE_SIZE = 200;

    console.log("ðŸš€ Monitor Starting (List: " + LIST_ID + ")...");

    function getSeenCache() {{
        const data = localStorage.getItem(STORAGE_KEY);
        return data ? JSON.parse(data) : [];
    }}

    function saveToCache(fingerprint) {{
        let cache = getSeenCache();
        if (!cache.includes(fingerprint)) {{
            cache.push(fingerprint);
            if (cache.length > MAX_CACHE_SIZE) cache = cache.slice(-MAX_CACHE_SIZE);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(cache));
        }}
    }}

    function getState() {{
        const data = localStorage.getItem(STATE_KEY);
        return data ? JSON.parse(data) : {{ lastRunTime: 0, lastTweetId: null, lastTweetTime: null }};
    }}

    function saveState(lastRunTime, lastTweetId, lastTweetTime) {{
        const s = getState();
        localStorage.setItem(STATE_KEY, JSON.stringify({{
            lastRunTime: lastRunTime !== undefined ? lastRunTime : s.lastRunTime,
            lastTweetId: lastTweetId !== undefined ? lastTweetId : s.lastTweetId,
            lastTweetTime: lastTweetTime !== undefined ? lastTweetTime : s.lastTweetTime
        }}));
    }}

    function getTweetIdFromArticle(article) {{
        const linkEl = article.querySelector('time')?.closest('a');
        if (!linkEl || !linkEl.href) return null;
        const m = linkEl.href.match(/\/status\/(\d+)/);
        return m ? m[1] : null;
    }}

    function getTweetTimeFromArticle(article) {{
        const timeEl = article.querySelector('time');
        return timeEl ? timeEl.getAttribute('datetime') : null;
    }}

    function getAuthorFromArticle(article) {{
        const authorLink = article.querySelector('a[href^="/"]');
        if (authorLink && authorLink.href) {{
            const m = authorLink.href.match(/^https?:\\/\\/[^/]+\\/([^/]+)/);
            return m ? m[1] : "unknown";
        }}
        return "unknown";
    }}

    function sendToApi(tweetId, authorHandle, text, url, postedAt) {{
        GM_xmlhttpRequest({{ method: "POST", url: API_URL + "/api/tweet", headers: {{ "Content-Type": "application/json" }}, data: JSON.stringify({{ tweet_id: tweetId, author_handle: authorHandle, text: text, url: url || null, posted_at: postedAt || null }}), onload: function(res) {{ if (res.status >= 200 && res.status < 300) console.log("%cðŸ“¤ Sent to DB: " + authorHandle, "color: #00ba7c;"); else console.warn("API " + res.status); }}, onerror: function() {{ console.warn("API failed (run python news/tweets_api.py)"); }} }});
    }}

    function processMatch(article, text, tweetUrl, tweetId, tweetTime) {{
        const cache = getSeenCache();
        const fingerprint = text.substring(0, 120);
        if (cache.includes(fingerprint)) return;
        const lowerText = text.toLowerCase();
        for (const kw of KEYWORDS) {{
            if (lowerText.includes(kw.toLowerCase())) {{
                const author = getAuthorFromArticle(article);
                const id = tweetId || getTweetIdFromArticle(article);
                const time = tweetTime || getTweetTimeFromArticle(article);
                sendToApi(id || String(Date.now()), author, text, tweetUrl, time);
                saveToCache(fingerprint);
                saveState(Date.now(), id, time);
                break;
            }}
        }}
    }}

    function scan() {{
        const articles = document.querySelectorAll('article[data-testid="tweet"]');
        articles.forEach(article => {{
            const textEl = article.querySelector('[data-testid="tweetText"]');
            if (!textEl) return;
            const text = textEl.innerText;
            const linkEl = article.querySelector('time')?.closest('a');
            const tweetUrl = linkEl ? linkEl.href : null;
            processMatch(article, text, tweetUrl, getTweetIdFromArticle(article), getTweetTimeFromArticle(article));
        }});
        saveState(Date.now());
    }}

    function catchUpScan() {{
        console.log("ðŸ”„ Catch-up: scraping tweets until last seen...");
        const state = getState();
        const articles = Array.from(document.querySelectorAll('article[data-testid="tweet"]'));
        const items = [];
        articles.forEach(article => {{
            const textEl = article.querySelector('[data-testid="tweetText"]');
            if (!textEl) return;
            const text = textEl.innerText;
            const linkEl = article.querySelector('time')?.closest('a');
            const tweetUrl = linkEl ? linkEl.href : null;
            items.push({{ article, text, tweetUrl, tweetId: getTweetIdFromArticle(article), tweetTime: getTweetTimeFromArticle(article) }});
        }});
        items.sort((a, b) => (b.tweetTime || '').localeCompare(a.tweetTime || ''));
        for (const item of items) {{
            if (state.lastTweetId && item.tweetId === state.lastTweetId) break;
            if (state.lastTweetTime && item.tweetTime && item.tweetTime <= state.lastTweetTime) break;
            processMatch(item.article, item.text, item.tweetUrl, item.tweetId, item.tweetTime);
        }}
        saveState(Date.now());
    }}

    function maybeCatchUpThenScan() {{
        const state = getState();
        const gap = (Date.now() - state.lastRunTime) / (60 * 1000);
        if (gap >= CATCH_UP_THRESHOLD_MINUTES) catchUpScan();
        else scan();
    }}

    const observer = new MutationObserver(() => {{
        const state = getState();
        if ((Date.now() - state.lastRunTime) / (60 * 1000) >= CATCH_UP_THRESHOLD_MINUTES) return;
        scan();
    }});
    observer.observe(document.body, {{ childList: true, subtree: true }});
    setTimeout(() => {{ console.log("ðŸ”„ Refreshing..."); window.location.reload(); }}, REFRESH_MINUTES * 60 * 1000);
    setInterval(() => console.log("Alive - " + new Date().toLocaleTimeString()), 30000);
    maybeCatchUpThenScan();
}})();
"#,
        name_escaped,
        version,
        keywords_js,
        list_id,
        monitor.refresh_minutes
    )
}

#[tauri::command]
fn list_monitors(app: tauri::AppHandle) -> Result<Vec<Monitor>, String> {
    let path = monitors_path(&app)?;
    if !path.exists() {
        return Ok(vec![]);
    }
    let s = fs::read_to_string(&path).map_err(|e| e.to_string())?;
    let list: Vec<Monitor> = serde_json::from_str(&s).unwrap_or_default();
    Ok(list)
}

#[tauri::command]
fn add_monitor(
    app: tauri::AppHandle,
    name: String,
    list_url: String,
    keywords: Vec<String>,
    refresh_minutes: Option<u32>,
) -> Result<Monitor, String> {
    let mut list = list_monitors(app.clone())?;
    let id = uuid::Uuid::new_v4().to_string();
    let monitor = Monitor {
        id: id.clone(),
        name: name.trim().to_string(),
        list_url: list_url.trim().to_string(),
        keywords: keywords
            .into_iter()
            .map(|k| k.trim().to_string())
            .filter(|k| !k.is_empty())
            .collect(),
        refresh_minutes: refresh_minutes.unwrap_or(1),
    };
    list.push(monitor.clone());
    let path = monitors_path(&app)?;
    fs::write(
        &path,
        serde_json::to_string_pretty(&list).map_err(|e| e.to_string())?,
    )
    .map_err(|e| e.to_string())?;
    Ok(monitor)
}

#[tauri::command]
fn delete_monitor(app: tauri::AppHandle, id: String) -> Result<(), String> {
    let mut list = list_monitors(app.clone())?;
    list.retain(|m| m.id != id);
    let path = monitors_path(&app)?;
    fs::write(
        &path,
        serde_json::to_string_pretty(&list).map_err(|e| e.to_string())?,
    )
    .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
fn generate_script(monitor: Monitor) -> Result<String, String> {
    Ok(generate_tampermonkey_script(&monitor))
}

#[tauri::command]
fn parse_list_url(list_url: String) -> Result<Option<String>, String> {
    Ok(parse_list_id_from_url(&list_url))
}

/// Open a URL in the system default browser.
#[tauri::command]
fn open_url(url: String) -> Result<(), String> {
    opener::open(url).map_err(|e| e.to_string())
}

/// Default base URL for the tweets API (run python news/tweets_api.py).
const DEFAULT_TWEETS_API: &str = "http://localhost:8765";

#[derive(serde::Deserialize)]
struct TweetsResponse {
    ok: Option<bool>,
    tweets: Option<Vec<TweetRow>>,
    error: Option<String>,
}

#[derive(serde::Deserialize, serde::Serialize)]
pub struct TweetRow {
    pub id: Option<u64>,
    pub tweet_id: Option<String>,
    pub author_handle: Option<String>,
    pub text: Option<String>,
    pub url: Option<String>,
    pub posted_at: Option<String>,
    pub inserted_at: Option<String>,
}

/// Fetch recent tweets from the local tweets API (for Notifications tab).
#[tauri::command]
fn fetch_recent_tweets(limit: Option<u32>) -> Result<Vec<TweetRow>, String> {
    let base = std::env::var("ODDSMANAGER_TWEETS_API").unwrap_or_else(|_| DEFAULT_TWEETS_API.to_string());
    let limit = limit.unwrap_or(100).min(500);
    let url = format!("{}/api/tweets?limit={}", base.trim_end_matches('/'), limit);
    let client = reqwest::blocking::Client::builder()
        .timeout(std::time::Duration::from_secs(10))
        .build()
        .map_err(|e| e.to_string())?;
    let res = client.get(&url).send().map_err(|e| e.to_string())?;
    let status = res.status();
    let body: TweetsResponse = res.json().map_err(|e| e.to_string())?;
    if status.as_u16() >= 400 {
        return Err(body.error.unwrap_or_else(|| status.to_string()));
    }
    body.tweets.ok_or_else(|| body.error.unwrap_or_else(|| "No tweets key".to_string()))
}

/// Resolve OddsManager project root (parent of desktop/, where news/ and db.py live).
fn project_root() -> Result<PathBuf, String> {
    if let Ok(root) = std::env::var("ODDSMANAGER_PROJECT_ROOT") {
        let p = PathBuf::from(root);
        if p.join("news").join("headless_list_monitor.py").exists() {
            return Ok(p);
        }
    }
    let exe = std::env::current_exe().map_err(|e| e.to_string())?;
    // exe is typically .../desktop/target/debug/odds-manager-desktop.exe
    // -> desktop dir = exe.parent().parent().parent()
    let mut dir = exe.parent().ok_or("no exe dir")?.to_path_buf();
    for _ in 0..2 {
        dir = dir.parent().ok_or("no parent")?.to_path_buf();
    }
    // dir is now desktop/
    let root = dir.parent().ok_or("no project root")?;
    if root.join("news").join("headless_list_monitor.py").exists() {
        Ok(root.to_path_buf())
    } else {
        Err(format!(
            "Project root not found (expected news/headless_list_monitor.py under {}). Set ODDSMANAGER_PROJECT_ROOT.",
            root.display()
        ))
    }
}

/// Start headless browser monitor for this monitor config. Writes config to app data and spawns
/// python news/headless_list_monitor.py --config <path>. Process runs in background.
#[tauri::command]
fn start_headless_monitor(app: tauri::AppHandle, monitor: Monitor) -> Result<(), String> {
    let root = project_root()?;
    let script = root.join("news").join("headless_list_monitor.py");
    if !script.exists() {
        return Err(format!("Script not found: {}", script.display()));
    }
    let config_dir = app.path().app_data_dir().map_err(|e| e.to_string())?;
    fs::create_dir_all(&config_dir).map_err(|e| e.to_string())?;
    let config_path = config_dir.join(format!("monitor_{}.json", monitor.id));
    let config = serde_json::json!({
        "list_url": monitor.list_url,
        "keywords": monitor.keywords,
        "refresh_minutes": monitor.refresh_minutes,
    });
    fs::write(&config_path, serde_json::to_string_pretty(&config).unwrap()).map_err(|e| e.to_string())?;
    let python = which_python();
    let mut cmd = Command::new(python);
    cmd.arg(script)
        .arg("--config")
        .arg(&config_path)
        .current_dir(&root);
    cmd.spawn().map_err(|e| e.to_string())?;
    Ok(())
}

fn which_python() -> String {
    std::env::var("ODDSMANAGER_PYTHON").unwrap_or_else(|_| "python".to_string())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_shell::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_fs::init())
        .invoke_handler(tauri::generate_handler![
            list_monitors,
            add_monitor,
            delete_monitor,
            generate_script,
            parse_list_url,
            open_url,
            start_headless_monitor,
            fetch_recent_tweets,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
